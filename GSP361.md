# Build LookML Objects in Looker: Challenge Lab

## Task 1. Create dimensions and measures

#### Your marketing team is requesting a new view to help them calculate how many users that found their website via search that have completed orders. In addition, they want to then see the gross margin of sales and the number of return days for each order. In this section, you will build dimensions and measures to answer these questions.

## Open the order_items view

#### 1. Click the toggle button to enter Development mode.

#### 2. Navigate to the the qwiklabs-ecommerce project and open the order_items view file.

## Create dimensions and measures

#### Inside of the order_items view file, you can add your new dimensions and measures after the total_revenue_from_completed_orders measure (around line 128).

#### 1. Create a dimension that returns a boolean value if the user traffic source was from Search. Name this dimension is_search_source.

```bash
dimension: is_search_source {
  type: yesno
  sql: ${users.traffic_source} = "Search" ;;
}
```

#### 2. Use this newly built is_search_source dimension to create a measure that sums the sale price from Search users with a Complete status on their order. Name this measure sales_from_complete_search_users.

```bash
measure: sales_from_complete_search_users {
  type: sum
  sql: ${TABLE}.sale_price ;;
  filters: [is_search_source: "Yes", order_items.status: "Complete"]
}
```

#### 3. Create a new measure that computes a sum of the total gross margin (sale price - cost). Name this measure total_gross_margin.

```bash
measure: total_gross_margin {
  type: sum
  sql: ${TABLE}.sale_price - ${inventory_items.cost} ;;
}
```

#### 4. Create a new dimension that computes the number of days between the Order Delivered Date and the Order Return Date. The interval should be calculated in days. Name this dimension return_days.

```bash
dimension: return_days {
  type: number
  sql: DATE_DIFF(${order_items.delivered_date}, ${order_items.returned_date}, DAY);;
}
```

#### 5. Click Validate LookML to validate your code.

#### 6. Click Commit Changes and Push, then click Deploy to Production.

---

## Task 2. Create a persistent derived table

#### Your data analytics team has requested a derived table to include specific details about a user. It will need to include their Order ID, User ID, Total Revenue, Age, City, and State to conduct market research on where to launch an advertisement campaign. Since they will need to be using this table heavily over the next few months, the table should be already created reducing query time and database load.

#### In this section, you will create a native derived table and persist it based on the pre-defined datagroup (cache policy) in the model.

## Create a native derived table

#### 1. From the Order Items Explore, create a native derived table named user_details that contains the following details for each user in the following order:

```bash
view: user_details {
  derived_table: {
    explore_source: order_items {
      column: order_id {}
      column: user_id {}
      column: total_revenue {}
      column: age { field: users.age }
      column: city { field: users.city }
      column: state { field: users.state }
    }
  }

  dimension: order_id {
    description: ""
    type: number
  }

  dimension: user_id {
    description: ""
    type: number
  }

  dimension: total_revenue {
    description: ""
    type: number
  }

  dimension: age {
    description: ""
    type: number
  }

  dimension: city {
    description: ""
  }

  dimension: state {
    description: ""
  }
}
```

#### 2. Once you've created the derived table, add the code to a new view file named user_details. Move this file into the views folder.

#### 3. Finally, join your new user_details view to the Order Items Explore. Make sure to set the join field as user_id on the order_items view and use a many to one relationship.

```bash
join: user_details {
  type: left_outer
  sql_on: ${order_items.user_id} = ${user_details.user_id} ;;
  relationship: many_to_one
}
```

#### 4. Click Commit Changes and Push, then click Deploy to Production.

## Persist the derived table

#### 1. Persist the user_details derived table based on the pre-defined datagroup (cache policy) in the model file.

#### 2. Set the persisted derived table to stay up for a set duration of <HOURS> hours.

#### 3. Click Validate LookML to validate your code.

#### 4. Click Commit Changes and Push, then click Deploy to Production.

---

## Task 3. Use Explore filters

#### In this section, you will choose the correct type of filter to use based off of different business requirements. For each filter you use, replace it with the filter in the next section for the grading to accurately check your progress.

## Filter #1

#### Your marketing team has requested that you create an Explore that only shows orders where the sale price is over $<SALE_PRICE>. Additionally, they don't want there to be any visible filters in the Explore that can be modified.

#### Add a filter to the Order Items Explore to include only items where the sale price is greater than or equal to <SALE_PRICE>. This will be used to omit any orders from the Explore that are less than $<SALE_PRICE>.

```bash
sql_always_where: ${sale_price} >= <SALE_PRICE> ;;
```

## Filter #2

#### Your marketing team has requested an Explore where there is a default filter on the shipped date which can be overridden if they apply a filter on the status or delivered date. They'd like the shipped date to default to the year 2018.

#### 1. Remove the previous filter.

#### 2. Next, add a filter to the Order Items Explore to only return data for orders that were shipped in the year 2018, unless a filter is applied to the Order Item Status or Order Item Delivered Date.

#### 3. Use the shipped_date dimension for this filter.

```bash
conditionally_filter: {
  filters: [order_items.shipped_date: "2018"]
  unless: [order_items.status, order_items.delivered_date]
}
```

## Filter #3

#### Your marketing team has requested that you create an Explore that only shows orders where the average sale price is more than $<AVERAGE_SALE_PRICE>. Additionally, they don't want there to be any visible filters in the Explore that can be modified.

#### 1. Remove the previous filter.

#### 2. Next, add a filter to the Order Items Explore to filter out all the items where the average sale price is more than <AVERAGE_SALE_PRICE>. That is, use a filter to only show orders with an average sale price of $<AVERAGE_SALE_PRICE> or more.

```bash
sql_always_having: ${average_sale_price} > <AVERAGE_SALE_PRICE> ;;
```

## Filter #4

#### Finally, your marketing team has requested that you build an Explore to include a certain set of filters with default values that may be changed, but not removed. The idea is to not request all of the possible data at one time by filtering by specific dimensions, which should save on computing costs.

#### Specifically, they want the set of filters to be on the Order Status, State, and Traffic source. The default values should be set to Shipped, California, and Search, respectively.

#### 1. Remove the previous filter.

#### 2. Next, use a filter to define default values for the Order Status, State, and Traffic Source for the Order Items Explore. Make sure that the filter is required for the business user, but they will still be able to provide different values for these dimensions.

```bash
always_filter: {
  filters: [order_items.status: "Shipped", users.state: "California", users.traffic_source:
  "Search"]
}
```

---

## Task 4. Apply a datagroup to an Explore

#### Lastly, you've been requested to update the caching policy of your LookML model. Your team would like you to update the number of hours to keep a cached result to <HOURS> hours.

#### 1. Remove any filters you created from the previous section.

#### 2. Inside of your model file, create a new datagroup named order_items_challenge_datagroup that has a maximum caching age of <HOURS> hours, and uses the following sql trigger: SELECT MAX(order_item_id) from order_items ;;.

```bash
datagroup: order_items_challenge_datagroup {
  sql_trigger: SELECT MAX(order_item_id) from order_items ;;
  max_cache_age: "<HOURS> hours"
}
```

#### 3. Apply the datagroup at the model level to apply it as the default for all Explore.

```bash
persist_with: order_items_challenge_datagroup
```

#### 4. Click Validate LookML to validate your code.

#### 5. Click Commit Changes and Push, then click Deploy to Production.
